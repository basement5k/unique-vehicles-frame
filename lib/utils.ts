import { kv } from '@vercel/kv';\nimport { Ratelimit } from '@upstash/ratelimit';\nimport { Redis } from '@upstash/redis';\nimport { FrameMessage, SessionData } from '@/types';\nimport { frameMessageSchema } from '@/types';\nimport { Message, isValidMessageSignature } from '@farcaster/core';\n\n// Initialize rate limiter\nconst redis = new Redis({\n  url: process.env.KV_REST_API_URL || '',\n  token: process.env.KV_REST_API_TOKEN || '',\n});\n\n// Create rate limiter: 10 requests per 10 seconds per user\nexport const ratelimit = new Ratelimit({\n  redis,\n  limiter: Ratelimit.slidingWindow(10, '10 s'),\n});\n\n// Validate Frame message from Farcaster\nexport async function validateFrameMessage(body: unknown): Promise<FrameMessage | null> {\n  try {\n    // Parse and validate the message structure\n    const result = frameMessageSchema.safeParse(body);\n    if (!result.success) {\n      console.error('Frame message validation failed:', result.error);\n      return null;\n    }\n\n    const { untrustedData, trustedData } = result.data;\n\n    // If we have message bytes, validate the signature\n    if (trustedData?.messageBytes) {\n      const bytes = Buffer.from(trustedData.messageBytes, 'hex');\n      const message = Message.decode(bytes);\n      const isValidSignature = await isValidMessageSignature(message);\n\n      if (!isValidSignature) {\n        console.error('Invalid message signature');\n        return null;\n      }\n    }\n\n    return result.data;\n  } catch (error) {\n    console.error('Error validating frame message:', error);\n    return null;\n  }\n}\n\n// Generate a session ID\nexport function generateSessionId(fid: number) {\n  return `session:${fid}:${Date.now()}`;\n}\n\n// Store session data\nexport async function storeSessionData(fid: number, data: Partial<SessionData>) {\n  const sessionId = generateSessionId(fid);\n  const sessionData: SessionData = {\n    fid,\n    step: 'capture',\n    timestamp: Date.now(),\n    ...data,\n  };\n\n  // Store session with 1 hour expiry\n  await kv.set(sessionId, sessionData, { ex: 60 * 60 });\n  return sessionId;\n}\n\n// Get session data\nexport async function getSessionData(sessionId: string): Promise<SessionData | null> {\n  try {\n    const data = await kv.get<SessionData>(sessionId);\n    return data;\n  } catch (error) {\n    console.error('Error retrieving session data:', error);\n    return null;\n  }\n}\n\n// Update session data\nexport async function updateSessionData(sessionId: string, data: Partial<SessionData>) {\n  try {\n    const currentData = await getSessionData(sessionId);\n    if (!currentData) return null;\n\n    const updatedData = { ...currentData, ...data, timestamp: Date.now() };\n    await kv.set(sessionId, updatedData, { ex: 60 * 60 });\n    return updatedData;\n  } catch (error) {\n    console.error('Error updating session data:', error);\n    return null;\n  }\n}\n\n// Helper to format error responses\nexport function errorResponse(message: string, status = 400) {\n  return new Response(JSON.stringify({ error: message }), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  });\n}\n\n// Helper to format frame responses\nexport function frameResponse({\n  image,\n  postUrl,\n  buttons,\n  input,\n  state,\n}: {\n  image: string;\n  postUrl: string;\n  buttons: Array<string>;\n  input?: { text: string };\n  state?: Record<string, string>;\n}) {\n  const frameMetadata = [\n    { name: 'fc:frame', content: 'vNext' },\n    { name: 'fc:frame:image', content: image },\n    { name: 'fc:frame:post_url', content: postUrl },\n  ];\n\n  // Add buttons\n  buttons.forEach((button, index) => {\n    frameMetadata.push({ name: `fc:frame:button:${index + 1}`, content: button });\n  });\n\n  // Add input if provided\n  if (input) {\n    frameMetadata.push({ name: 'fc:frame:input:text', content: input.text });\n  }\n\n  // Add state if provided\n  if (state) {\n    const stateString = Object.entries(state)\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&');\n    frameMetadata.push({ name: 'fc:frame:state', content: stateString });\n  }\n\n  return new Response(\n    `<!DOCTYPE html>\n    <html>\n      <head>\n        ${frameMetadata.map((meta) => `<meta property=\"${meta.name}\" content=\"${meta.content}\" />`).join('')}\n      </head>\n      <body></body>\n    </html>`,\n    { headers: { 'Content-Type': 'text/html' } }\n  );\n}